const { expect } = require("chai");
const { ethers } = require("hardhat");
const { groth16 } = require("snarkjs");
const { utils } = require("ffjavascript");

// A helper function to build the calldata for the ZK verifier
function buildSolidityCalldata(proof, publicSignals) {
    const a = proof.pi_a.slice(0, 2);
    const b = [
        proof.pi_b[0].slice(0).reverse(),
        proof.pi_b[1].slice(0).reverse(),
    ];
    const c = proof.pi_c.slice(0, 2);
    const pI = publicSignals;

    return { a, b, c, pI };
}

describe("Aegis Protocol vs. Baseline Model Full Test Suite", function () {
    // --- SHARED SETUP ---
    let owner, validator1, validator2, validator3, validator4, validator5, attacker, user;
    let baselineModel, lockingContract, aegisVerifier;

    // CORRECTED: Declare the constant here, but initialize it inside the `before` hook
    // to ensure the `ethers` object is ready.
    let DEPOSIT_AMOUNT;

    before(async function () {
        // Initialize constants
        DEPOSIT_AMOUNT = ethers.utils.parseEther("1"); // 1 ETH

        // Get signers
        [owner, validator1, validator2, validator3, validator4, validator5, attacker, user] = await ethers.getSigners();

        // --- DEPLOY BASELINE MODEL ---
        const BaselineFactory = await ethers.getContractFactory("BaselineValidatorModel");
        const validators = [validator1.address, validator2.address, validator3.address, validator4.address, validator5.address];
        baselineModel = await BaselineFactory.deploy(validators);
        await baselineModel.deployed();

        // --- DEPLOY AEGIS PROTOCOL ---
        // 1. Deploy the Verifier contract (generated by snarkjs)
        const VerifierFactory = await ethers.getContractFactory("Groth16Verifier");
        const verifier = await VerifierFactory.deploy();
        await verifier.deployed();

        // 2. Deploy the LockingContract (source chain)
        const LockingFactory = await ethers.getContractFactory("LockingContract");
        lockingContract = await LockingFactory.deploy();
        await lockingContract.deployed();

        // 3. Deploy the AegisVerifier (destination chain)
        const AegisFactory = await ethers.getContractFactory("AegisVerifier");
        aegisVerifier = await AegisFactory.deploy(verifier.address);
        await aegisVerifier.deployed();

        // Fund the AegisVerifier so it can release funds
        await owner.sendTransaction({
            to: aegisVerifier.address,
            value: ethers.utils.parseEther("10"),
        });
    });

    // --- TEST SUITE 1: SECURITY ANALYSIS ---
    describe("⚔️ Security: Simulated Attack Vectors", function () {
        it("BASELINE FAILURE: Should allow fund withdrawal with compromised validator keys", async function () {
            console.log("\n--- Running Attack on Baseline Model ---");
            const maliciousCallData = "0x"; // Simple ETH transfer
            const txHash = await baselineModel.getTransactionHash(attacker.address, DEPOSIT_AMOUNT, maliciousCallData);
            
            // Attacker gets signatures from 3 compromised validators
            const sig1 = await validator1.signMessage(ethers.utils.arrayify(txHash));
            const sig2 = await validator2.signMessage(ethers.utils.arrayify(txHash));
            const sig3 = await validator3.signMessage(ethers.utils.arrayify(txHash));

            const signatures = [
                ethers.utils.splitSignature(sig1),
                ethers.utils.splitSignature(sig2),
                ethers.utils.splitSignature(sig3),
            ].map(s => ethers.utils.solidityPack(["bytes32", "bytes32", "uint8"], [s.r, s.s, s.v]));

            const attackerInitialBalance = await ethers.provider.getBalance(attacker.address);

            const tx = await baselineModel.connect(attacker).executeTransaction(attacker.address, DEPOSIT_AMOUNT, maliciousCallData, signatures);
            const receipt = await tx.wait();

            const attackerFinalBalance = await ethers.provider.getBalance(attacker.address);

            console.log(`Baseline Attack Gas Cost: ${receipt.gasUsed.toString()}`);
            expect(attackerFinalBalance).to.be.gt(attackerInitialBalance);
            console.log("Outcome: VULNERABLE. Funds were stolen.");
        });

        it("AEGIS SUCCESS: Should REJECT a malicious proposal without a valid ZK proof", async function () {
            console.log("\n--- Running Attack on Aegis Protocol ---");
            // Attacker tries to call releaseFunds directly with fake data
            const fakeProof = { a: [0, 0], b: [[0, 0], [0, 0]], c: [0, 0], pI: [0, 0] };

            await expect(
                aegisVerifier.connect(attacker).releaseFunds(
                    fakeProof.a,
                    fakeProof.b,
                    fakeProof.c,
                    fakeProof.pI,
                    attacker.address,
                    DEPOSIT_AMOUNT
                )
            ).to.be.revertedWith("Aegis: Invalid ZK proof");
            console.log("Outcome: SECURE. Malicious proposal was rejected.");
        });
    });

    // --- TEST SUITE 2: PERFORMANCE & VIABILITY ---
    describe("⏱️ Performance: Gas and Latency Analysis", function () {
        let proof, publicSignals;
        let baselineGas, aegisGas;

        it("Should execute a LEGITIMATE transaction on the Baseline model and record gas", async function () {
            const legitimateCallData = "0x";
            const txHash = await baselineModel.getTransactionHash(user.address, DEPOSIT_AMOUNT, legitimateCallData);

            // Create signatures in sorted order of signers
            const signers = [validator1, validator2, validator3].sort((a, b) => a.address.localeCompare(b.address));

            const signatures = [];
            for (const signer of signers) {
                const sig = await signer.signMessage(ethers.utils.arrayify(txHash));
                signatures.push(ethers.utils.solidityPack(["bytes32", "bytes32", "uint8"], [ethers.utils.splitSignature(sig).r, ethers.utils.splitSignature(sig).s, ethers.utils.splitSignature(sig).v]));
            }

            const tx = await baselineModel.connect(user).executeTransaction(user.address, DEPOSIT_AMOUNT, legitimateCallData, signatures);
            const receipt = await tx.wait();
            baselineGas = receipt.gasUsed;
            console.log(`\nLegitimate Baseline Tx Gas: ${baselineGas.toString()}`);
        });


        it("Should generate a ZK proof and record latency", async function () {
            const secret = ethers.BigNumber.from(ethers.utils.randomBytes(32));
            const destinationChainId = 31337; // Hardhat network

            // This mimics the hash from the contract
            const eventHash = ethers.utils.keccak256(
                ethers.utils.solidityPack(
                    ["address", "uint256", "uint256", "uint256"],
                    [user.address, DEPOSIT_AMOUNT, destinationChainId, secret]
                )
            );
            
            // This is a simplified hash for the nullifier, matching the circuit
            const nullifierHash = ethers.utils.keccak256(ethers.utils.solidityPack(["uint256"], [secret]));

            const input = {
                depositor: ethers.BigNumber.from(user.address).toString(),
                amount: DEPOSIT_AMOUNT.toString(),
                destinationChainId: destinationChainId.toString(),
                secret: secret.toString(),
            };

            console.log("Generating ZK proof...");
            const startTime = Date.now();
            // NOTE: You need to have the compiled circuit files (`AegisCircuit.wasm` and `AegisCircuit_final.zkey`) in your project root
            const { proof: generatedProof, publicSignals: generatedPublicSignals } = await groth16.fullProve(input, "circuits/AegisCircuit.wasm", "circuits/AegisCircuit_final.zkey");
            const endTime = Date.now();
            
            proof = generatedProof;
            publicSignals = generatedPublicSignals;

            const latency = (endTime - startTime) / 1000;
            console.log(`Proof Generation Latency: ${latency} seconds`);
            expect(latency).to.be.lessThan(5); // We expect it to be fast
        });

        it("Should execute a LEGITIMATE transaction on Aegis and record gas", async function () {
            const { a, b, c, pI } = buildSolidityCalldata(proof, publicSignals);

            const tx = await aegisVerifier.connect(user).releaseFunds(a, b, c, pI, user.address, DEPOSIT_AMOUNT);
            const receipt = await tx.wait();
            aegisGas = receipt.gasUsed;
            console.log(`Legitimate Aegis Tx Gas: ${aegisGas.toString()}`);
        });

        it("Should calculate and display the final overhead", function () {
            const overhead = ((aegisGas - baselineGas) / baselineGas) * 100;
            console.log(`\n--- FINAL RESULTS ---`);
            console.log(`Gas Overhead: ${overhead.toFixed(2)}%`);
            console.log(`---------------------`);

            expect(overhead).to.be.lessThan(50); // A reasonable expectation
        });
    });
});
