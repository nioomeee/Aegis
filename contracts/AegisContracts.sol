// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

import "hardhat/console.sol";

// This is the Verifier interface generated by `snarkjs`.
// You would generate this file after compiling your circuit.
// It contains the `verifyProof` function that checks the ZK proof.
interface IVerifier {
    function verifyProof(
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c,
        uint256[2] memory input
    ) external view returns (bool r);
}

/**
 * @title LockingContract
 * @author Niomi Langaliya
 * @notice This contract would live on the SOURCE chain (e.g., Ethereum).
 * Its only job is to accept user deposits and emit a secure, provable event.
 * The event hash is what the off-chain prover will use to generate the ZK proof.
 */
contract LockingContract {
    event DepositMade(bytes32 indexed eventHash);

    /**
     * @notice User calls this to deposit funds for bridging.
     * @param _destinationChainId The chain ID of the destination network.
     * @param _secret A secret value chosen by the user, used to generate the hashes.
     */
    function depositForBridge(
        uint256 _destinationChainId,
        uint256 _secret
    ) public payable {
        require(msg.value > 0, "Aegis: Deposit must be > 0");

        // On-chain, we compute the event hash that the ZK circuit will prove against.
        
        // This MUST match the hashing logic inside the circuit.
        // For this PoC, we use keccak256 as a stand-in for a SNARK-friendly hash.
        bytes32 eventHash = keccak256(
            abi.encodePacked(
                msg.sender,
                msg.value,
                _destinationChainId,
                _secret
            )
        );

        console.log("Source Chain: Deposit event emitted with hash:", eventHash);
        emit DepositMade(eventHash);
    }
}

/**
 * @title AegisVerifier
 * @author Niomi Langaliya
 * @notice This contract would live on the DESTINATION chain (e.g., Polygon).
 * It verifies the ZK proof submitted by a prover and, if valid, releases
 * the bridged funds. It is the cryptographic security guard of the Aegis protocol.
 */
contract AegisVerifier {
    // --- State Variables ---

    IVerifier public immutable i_verifier;
    // Mapping of used nullifiers to prevent replay attacks (double-spending).
    mapping(bytes32 => bool) public s_usedNullifiers;

    // --- Events ---

    event FundsReleased(address indexed to, uint256 amount);

    // --- Constructor ---

    constructor(address verifierAddress) {
        i_verifier = IVerifier(verifierAddress);
    }

    // --- Core Logic ---

    /**
     * @notice Verifies a ZK proof and releases funds to the original depositor.
     * @param a The ZK proof component 'a'.
     * @param b The ZK proof component 'b'.
     * @param c The ZK proof component 'c'.
     * @param publicInputs The public inputs to the circuit: [eventHash, nullifierHash].
     * @param _depositor The address of the original depositor.
     * @param _amount The amount they deposited.
     */
    function releaseFunds(
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c,
        uint256[2] memory publicInputs,
        address _depositor,
        uint256 _amount
    ) public {
        // The public inputs from the proof are uint256, so we cast them to bytes32.
        bytes32 eventHash = bytes32(publicInputs[0]);
        bytes32 nullifierHash = bytes32(publicInputs[1]);

        // 1. **REPLAY PROTECTION**: Crucially, check the nullifier FIRST.
        // This ensures a proof can only ever be used once.
        require(
            !s_usedNullifiers[nullifierHash],
            "Aegis: Replay attack - proof already used"
        );

        // 2. **ZK PROOF VERIFICATION**: Call the verifier contract to check the proof's validity.
        // This is the core cryptographic security check.
        bool isValid = i_verifier.verifyProof(a, b, c, publicInputs);
        require(isValid, "Aegis: Invalid ZK proof");

        // 3. If the proof is valid, mark the nullifier as used to prevent future replays.
        s_usedNullifiers[nullifierHash] = true;

        // 4. In a real bridge, you would mint pegged tokens. For this PoC,
        // we'll simulate it by transferring funds from this contract's balance.
        // Make sure the contract is funded for the test.
        (bool success, ) = _depositor.call{value: _amount}("");
        require(success, "Aegis: Fund transfer failed");

        emit FundsReleased(_depositor, _amount);
    }
}
